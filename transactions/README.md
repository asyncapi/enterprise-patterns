# Acknowledgement & Transactions

Some brokers allow us to send messages as part of a transaction and also let us decide when to acknowledge that a message has been sent or received. In this document, we overview message acknowledgment and distributed transactions, and how to define them using AsyncAPI bindings.

## Acknowledgment

### JMS message acknowledgement

JMS has a mechanism to flag [message acknowledgement mode](https://docs.oracle.com/javaee/7/api/javax/jms/Session.html). Its values can be `AUTO_ACKNOWLEDGE`, `DUPS_OK_ACKNOWLEDGE`, `CLIENT_ACKNOWLEDGE`, and `SESSION_TRANSACTED`.

```yaml
...
channels:
  myTopic:
    publish:
      bindings:
        jms:
          acknowledge: auto # dups_ok, client or session_transacted
      message:
        ...
```

The `acknowledge` field inside the `jms` object supports 4 possible values: `auto` (default), `dups_ok`, `client` or `session_transacted`.

#### `auto`

Maps to `AUTO_ACKNOWLEDGE`. With this acknowledgment mode, the session automatically acknowledges a client's receipt of a message either when the session has successfully returned from a call to receive or when the message listener the session has called to process the message successfully returns.

#### `dups_ok`

Maps to `DUPS_OK_ACKNOWLEDGE`. This acknowledgment mode instructs the session to lazily acknowledge the delivery of messages.

#### `client`

Maps to `CLIENT_ACKNOWLEDGE`. With this acknowledgment mode, the client acknowledges a consumed message by calling the message's acknowledge method.

#### `session_transacted`

Maps to `SESSION_TRANSACTED`. Wit this acknowledgment mode, the client will acknowledge a consumed message as part of a transaction.

### Java example

The definition above would be the equivalent of the following code in Java:

```java
package com.asyncapi.jms.acknowledgment;

import javax.jms.JMSConsumer;
import javax.jms.JMSContext;
import javax.jms.JMSException;
import javax.jms.Topic;
import javax.jms.TextMessage;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory;

public class MessageAcknowledgment {

	public static void main(String[] args) throws NamingException, JMSException {
		InitialContext context = new InitialContext();
		Topic topic = (Topic) context.lookup("topic/myTopic");

		try (ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory();
        JMSContext jmsContext = cf.createContext(JMSContext.AUTO_ACKNOWLEDGE)) {

			JMSConsumer consumer = jmsContext.createConsumer(topic);
			TextMessage message = (TextMessage) consumer.receive();
			System.out.println(message.getText());
			message.acknowledge();
		}
	}

}
```

## Distributed Transactions

Distributed trasactions are meant for situations when a program has to deal with multiple resources (databases, filesystem, etc.) as part of a transaction.

### JMS XA transactions

JMS XA transactions need transaction identifier (Xid) to uniquely identify a transaction over multiple resources and time.

```yaml
...
channels:
  myTopic:
    publish:
      bindings:
        jms:
          xid: my-transaction-id
      message:
        ...
```

Please note the `xid` field may not represent the final transaction id. Most computer programs will take the value of this field and will add unique autogenerated bytes to it.

#### Java example

```java
package com.asyncapi.jms.xatransactions;

import javax.jms.MessageConsumer;
import javax.jms.MessageProducer;
import javax.jms.Topic;
import javax.jms.Session;
import javax.jms.TextMessage;
import javax.jms.XAConnection;
import javax.jms.XAConnectionFactory;
import javax.jms.XASession;
import javax.naming.InitialContext;
import javax.transaction.xa.XAResource;
import javax.transaction.xa.Xid;
import java.nio.charset.StandardCharsets;

import org.apache.activemq.artemis.utils.UUIDGenerator;

public class XATransactions {

   public static void main(final String[] args) throws Exception {
      XAConnection connection = null;
      InitialContext initialContext = null;
      try {
         initialContext = new InitialContext();
         Topic topic = (Topic) initialContext.lookup("topic/myTopic");
         XAConnectionFactory cf = (XAConnectionFactory) initialContext.lookup("XAConnectionFactory");
         connection = cf.createXAConnection();
         connection.start();

         XASession xaSession = connection.createXASession();
         MessageConsumer xaConsumer = xaSession.createConsumer(topic);
         
         Xid xid1 = new DummyXid("my-transaction-id".getBytes(StandardCharsets.US_ASCII), 1, UUIDGenerator.getInstance().generateStringUUID().getBytes());
         XAResource xaRes = xaSession.getXAResource();
         xaRes.start(xid1, XAResource.TMNOFLAGS);

         TextMessage rm1 = (TextMessage) xaConsumer.receive();
         System.out.println("Message received: " + rm1.getText());
         TextMessage rm2 = (TextMessage) xaConsumer.receive();
         System.out.println("Message received: " + rm2.getText());

         
         xaRes.end(xid1, XAResource.TMSUCCESS);
         xaRes.prepare(xid1);
         xaRes.commit(xid1, false);
      } finally {
         if (initialContext != null) {
            initialContext.close();
         }
         if (connection != null) {
            connection.close();
         }
      }
   }
}
```

### Kafka transactions

In the case of Kafka, the transaction id is part of the protocol and can be set on producers as `transactional.id`. Along with the id, we can fine tune things like `transaction.timeout.ms` and `isolation.level` (for consumers only). We can define them with AsyncAPI as follows:

```yaml
...
channels:
  myTopic:
    publish:
      bindings:
        kafka:
          transaction:
            id: my-transactional-id # Maps to transactional.id
            timeout: 5000 # Maps to transaction.timeout.ms
            isolationLevel: read_committed # Maps to isolation.level. Defaults to read_uncommitted.
      message:
        ...
```
